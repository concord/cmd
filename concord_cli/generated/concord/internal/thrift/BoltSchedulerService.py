#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

from .ttypes import *
from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastbinary
  if fastbinary.version < 2:
     fastbinary = None
     warnings.warn("Disabling fastbinary, need at least version 2")
except:
  fastbinary = None

all_structs = []
UTF8STRINGS = bool(1) or sys.version_info.major >= 3
from thrift.util.Decorators import *

class Iface:
  def deployComputation(self, request=None):
    """
    Parameters:
     - request
    """
    pass

  def getComputationSlug(self, computationName=None):
    """
    Parameters:
     - computationName
    """
    pass

  def registerComputation(self, computation=None):
    """
    Parameters:
     - computation
    """
    pass

  def scaleComputation(self, computationName=None, instances=None):
    """
    Parameters:
     - computationName
     - instances
    """
    pass

  def killTask(self, taskId=None):
    """
    Parameters:
     - taskId
    """
    pass


class ContextIface:
  def deployComputation(self, handler_ctx, request=None):
    """
    Parameters:
     - request
    """
    pass

  def getComputationSlug(self, handler_ctx, computationName=None):
    """
    Parameters:
     - computationName
    """
    pass

  def registerComputation(self, handler_ctx, computation=None):
    """
    Parameters:
     - computation
    """
    pass

  def scaleComputation(self, handler_ctx, computationName=None, instances=None):
    """
    Parameters:
     - computationName
     - instances
    """
    pass

  def killTask(self, handler_ctx, taskId=None):
    """
    Parameters:
     - taskId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def deployComputation(self, request=None):
    """
    Parameters:
     - request
    """
    self.send_deployComputation(request)
    self.recv_deployComputation()

  def send_deployComputation(self, request=None):
    self._oprot.writeMessageBegin('deployComputation', TMessageType.CALL, self._seqid)
    args = deployComputation_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deployComputation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deployComputation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def getComputationSlug(self, computationName=None):
    """
    Parameters:
     - computationName
    """
    self.send_getComputationSlug(computationName)
    return self.recv_getComputationSlug()

  def send_getComputationSlug(self, computationName=None):
    self._oprot.writeMessageBegin('getComputationSlug', TMessageType.CALL, self._seqid)
    args = getComputationSlug_args()
    args.computationName = computationName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getComputationSlug(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getComputationSlug_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.e != None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getComputationSlug failed: unknown result");

  def registerComputation(self, computation=None):
    """
    Parameters:
     - computation
    """
    self.send_registerComputation(computation)
    self.recv_registerComputation()

  def send_registerComputation(self, computation=None):
    self._oprot.writeMessageBegin('registerComputation', TMessageType.CALL, self._seqid)
    args = registerComputation_args()
    args.computation = computation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerComputation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = registerComputation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def scaleComputation(self, computationName=None, instances=None):
    """
    Parameters:
     - computationName
     - instances
    """
    self.send_scaleComputation(computationName, instances)
    self.recv_scaleComputation()

  def send_scaleComputation(self, computationName=None, instances=None):
    self._oprot.writeMessageBegin('scaleComputation', TMessageType.CALL, self._seqid)
    args = scaleComputation_args()
    args.computationName = computationName
    args.instances = instances
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scaleComputation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scaleComputation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def killTask(self, taskId=None):
    """
    Parameters:
     - taskId
    """
    self.send_killTask(taskId)
    self.recv_killTask()

  def send_killTask(self, taskId=None):
    self._oprot.writeMessageBegin('killTask', TMessageType.CALL, self._seqid)
    args = killTask_args()
    args.taskId = taskId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_killTask(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = killTask_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["deployComputation"] = Processor.process_deployComputation
    self._processMap["getComputationSlug"] = Processor.process_getComputationSlug
    self._processMap["registerComputation"] = Processor.process_registerComputation
    self._processMap["scaleComputation"] = Processor.process_scaleComputation
    self._processMap["killTask"] = Processor.process_killTask

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_deployComputation(self, args, handler_ctx):
    result = deployComputation_result()
    try:
      self._handler.deployComputation(args.request)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deployComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deployComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getComputationSlug(self, args, handler_ctx):
    result = getComputationSlug_result()
    try:
      result.success = self._handler.getComputationSlug(args.computationName)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getComputationSlug', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getComputationSlug', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_registerComputation(self, args, handler_ctx):
    result = registerComputation_result()
    try:
      self._handler.registerComputation(args.computation)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'registerComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'registerComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_scaleComputation(self, args, handler_ctx):
    result = scaleComputation_result()
    try:
      self._handler.scaleComputation(args.computationName, args.instances)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'scaleComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'scaleComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_killTask(self, args, handler_ctx):
    result = killTask_result()
    try:
      self._handler.killTask(args.taskId)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'killTask', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'killTask', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["deployComputation"] = ContextProcessor.process_deployComputation
    self._processMap["getComputationSlug"] = ContextProcessor.process_getComputationSlug
    self._processMap["registerComputation"] = ContextProcessor.process_registerComputation
    self._processMap["scaleComputation"] = ContextProcessor.process_scaleComputation
    self._processMap["killTask"] = ContextProcessor.process_killTask

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_deployComputation(self, args, handler_ctx):
    result = deployComputation_result()
    try:
      self._handler.deployComputation(handler_ctx, args.request)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deployComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deployComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getComputationSlug(self, args, handler_ctx):
    result = getComputationSlug_result()
    try:
      result.success = self._handler.getComputationSlug(handler_ctx, args.computationName)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getComputationSlug', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getComputationSlug', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_registerComputation(self, args, handler_ctx):
    result = registerComputation_result()
    try:
      self._handler.registerComputation(handler_ctx, args.computation)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'registerComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'registerComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_scaleComputation(self, args, handler_ctx):
    result = scaleComputation_result()
    try:
      self._handler.scaleComputation(handler_ctx, args.computationName, args.instances)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'scaleComputation', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'scaleComputation', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_killTask(self, args, handler_ctx):
    result = killTask_result()
    try:
      self._handler.killTask(handler_ctx, args.taskId)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'killTask', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'killTask', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

# HELPER FUNCTIONS AND STRUCTURES

class deployComputation_args:
  """
  Attributes:
   - request
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = BoltComputationRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('deployComputation_args')
    if self.request != None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'request' in json_obj and json_obj['request'] is not None:
      self.request = BoltComputationRequest()
      self.request.readFromJson(json_obj['request'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(deployComputation_args)
deployComputation_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'request', [BoltComputationRequest, BoltComputationRequest.thrift_spec, False], None, 2, ), # 1
)

def deployComputation_args__init__(self, request=None,):
  self.request = request

deployComputation_args.__init__ = deployComputation_args__init__

class deployComputation_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('deployComputation_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(deployComputation_result)
deployComputation_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def deployComputation_result__init__(self, e=None,):
  self.e = e

deployComputation_result.__init__ = deployComputation_result__init__

class getComputationSlug_args:
  """
  Attributes:
   - computationName
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.computationName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getComputationSlug_args')
    if self.computationName != None:
      oprot.writeFieldBegin('computationName', TType.STRING, 1)
      oprot.writeString(self.computationName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.computationName, bytes) else oprot.writeString(self.computationName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'computationName' in json_obj and json_obj['computationName'] is not None:
      self.computationName = json_obj['computationName']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getComputationSlug_args)
getComputationSlug_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'computationName', True, None, 2, ), # 1
)

def getComputationSlug_args__init__(self, computationName=None,):
  self.computationName = computationName

getComputationSlug_args.__init__ = getComputationSlug_args__init__

class getComputationSlug_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getComputationSlug_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'success' in json_obj and json_obj['success'] is not None:
      self.success = json_obj['success']
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getComputationSlug_result)
getComputationSlug_result.thrift_spec = (
  (0, TType.STRING, 'success', False, None, 2, ), # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def getComputationSlug_result__init__(self, success=None, e=None,):
  self.success = success
  self.e = e

getComputationSlug_result.__init__ = getComputationSlug_result__init__

class registerComputation_args:
  """
  Attributes:
   - computation
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.computation = ComputationMetadata()
          self.computation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('registerComputation_args')
    if self.computation != None:
      oprot.writeFieldBegin('computation', TType.STRUCT, 1)
      self.computation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'computation' in json_obj and json_obj['computation'] is not None:
      self.computation = ComputationMetadata()
      self.computation.readFromJson(json_obj['computation'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(registerComputation_args)
registerComputation_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'computation', [ComputationMetadata, ComputationMetadata.thrift_spec, False], None, 2, ), # 1
)

def registerComputation_args__init__(self, computation=None,):
  self.computation = computation

registerComputation_args.__init__ = registerComputation_args__init__

class registerComputation_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('registerComputation_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(registerComputation_result)
registerComputation_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def registerComputation_result__init__(self, e=None,):
  self.e = e

registerComputation_result.__init__ = registerComputation_result__init__

class scaleComputation_args:
  """
  Attributes:
   - computationName
   - instances
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.computationName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.instances = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('scaleComputation_args')
    if self.computationName != None:
      oprot.writeFieldBegin('computationName', TType.STRING, 1)
      oprot.writeString(self.computationName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.computationName, bytes) else oprot.writeString(self.computationName)
      oprot.writeFieldEnd()
    if self.instances != None:
      oprot.writeFieldBegin('instances', TType.I64, 2)
      oprot.writeI64(self.instances)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'computationName' in json_obj and json_obj['computationName'] is not None:
      self.computationName = json_obj['computationName']
    if 'instances' in json_obj and json_obj['instances'] is not None:
      self.instances = long(json_obj['instances'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(scaleComputation_args)
scaleComputation_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'computationName', True, None, 2, ), # 1
  (2, TType.I64, 'instances', None, None, 2, ), # 2
)

def scaleComputation_args__init__(self, computationName=None, instances=None,):
  self.computationName = computationName
  self.instances = instances

scaleComputation_args.__init__ = scaleComputation_args__init__

class scaleComputation_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('scaleComputation_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(scaleComputation_result)
scaleComputation_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def scaleComputation_result__init__(self, e=None,):
  self.e = e

scaleComputation_result.__init__ = scaleComputation_result__init__

class killTask_args:
  """
  Attributes:
   - taskId
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('killTask_args')
    if self.taskId != None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId.encode('utf-8')) if UTF8STRINGS and not isinstance(self.taskId, bytes) else oprot.writeString(self.taskId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'taskId' in json_obj and json_obj['taskId'] is not None:
      self.taskId = json_obj['taskId']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(killTask_args)
killTask_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'taskId', True, None, 2, ), # 1
)

def killTask_args__init__(self, taskId=None,):
  self.taskId = taskId

killTask_args.__init__ = killTask_args__init__

class killTask_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('killTask_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(killTask_result)
killTask_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def killTask_result__init__(self, e=None,):
  self.e = e

killTask_result.__init__ = killTask_result__init__

fix_spec(all_structs)
del all_structs

