#!/usr/bin/env python
#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import print_function
from __future__ import absolute_import
import optparse
import os
import pprint
import sys
import traceback
from six.moves.urllib.parse import urlparse

if (not sys.argv[0].endswith("par") and
    os.getenv('PAR_UNPACK_TMP') == None):

    f = open(sys.argv[0], "r")

    f.readline() # This will be #!/bin/bash
    line = f.readline()
    f.close()

    # The par generator tool always has '# This par was made' as the
    # second line. See fbcode/tools/make_par/make_par.py
    if (not line.startswith('# This par was made')):
        print("""WARNING
        You are trying to run *-remote.py which is incorrect as the
        paths are not set up correctly. Instead, you should generate
        your thrift files with thrift_library and then run the
        resulting *-remote.par.
        For more information, please read
        http://fburl.com/python-remotes""")
        exit()

from thrift.transport import TTransport
from thrift.transport import TSocket
from thrift.transport import TSSLSocket
from thrift.transport import THttpClient
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TJSONProtocol
from thrift.protocol import THeaderProtocol

from . import BoltSchedulerService
from .ttypes import *


class Function(object):
    def __init__(self, name, return_type, args):
        self.name = name
        self.return_type = return_type
        self.args = args


FUNCTIONS = {
    'deployComputation': Function('deployComputation', 'void', [('BoltComputationRequest', 'request', 'BoltComputationRequest')]),
    'getComputationSlug': Function('getComputationSlug', 'string', [('string', 'computationName', 'string')]),
    'registerComputation': Function('registerComputation', 'void', [('ComputationMetadata', 'computation', 'ComputationMetadata')]),
    'scaleComputation': Function('scaleComputation', 'void', [('string', 'computationName', 'string'), ('i64', 'instances', 'i64')]),
    'killTask': Function('killTask', 'void', [('string', 'taskId', 'string')]),
}

def print_functions(out=sys.stdout):
    out.write('Functions:\n')
    for fn_name in sorted(FUNCTIONS):
        fn = FUNCTIONS[fn_name]
        if fn.return_type is None:
            out.write('  oneway void ')
        else:
            out.write('  %s ' % (fn.return_type,))
        out.write(fn_name + '(')
        out.write(', '.join('%s %s' % (type, name)
                            for type, name, true_type in fn.args))
        out.write(')\n')


def parse_host_port(value, default_port):
    parts = value.rsplit(':', 1)
    if len(parts) == 1:
        return (parts[0], default_port)
    try:
        port = int(parts[1])
    except ValueError:
        raise ValueError('invalid port: ' + parts[1])
    return (parts[0], port)


def main(argv):
    usage = '%prog [OPTIONS] FUNCTION [ARGS ...]'
    op = optparse.OptionParser(usage=usage, add_help_option=False)
    op.disable_interspersed_args()
    op.add_option('-h', '--host',
                  action='store', metavar='HOST[:PORT]',
                  help='The host and port to connect to')
    op.add_option('-u', '--url',
                  action='store',
                  help='The URL to connect to, for HTTP transport')
    op.add_option('-f', '--framed',
                  action='store_true', default=False,
                  help='Use framed transport')
    op.add_option('-s', '--ssl',
                  action='store_true', default=False,
                  help='Use SSL socket')
    op.add_option('-U', '--unframed',
                  action='store_true', default=False,
                  help='Use unframed transport')
    op.add_option('-j', '--json',
                  action='store_true', default=False,
                  help='Use TJSONProtocol')
    op.add_option('-c', '--compact',
                  action='store_true', default=False,
                  help='Use TCompactProtocol')
    op.add_option('-?', '--help',
                  action='help',
                  help='Show this help message and exit')

    (options, args) = op.parse_args(argv[1:])

    if not args:
        op.print_help(sys.stderr)
        print_functions(sys.stderr)
        return os.EX_USAGE

    # Before we try to connect, make sure
    # the function and arguments are valid
    fn_name = args[0]
    try:
        fn = FUNCTIONS[fn_name]
    except KeyError:
        print_functions(sys.stderr)
        print('\nerror: unknown function "%s"' % fn_name, 
                 file=sys.stderr)
        return os.EX_USAGE

    if len(args) != len(fn.args) + 1:
        print('error: %s requires exactly %d arguments'% 
                 (fn_name, len(fn.args)), file=sys.stderr)
        return os.EX_USAGE
    fn_args = []
    for arg, arg_info in zip(args[1:], fn.args):
        if arg_info[2] == 'string':
            # For ease-of-use, we don't eval string arguments, simply so
            # users don't have to wrap the arguments in quotes
            fn_args.append(arg)
            continue

        try:
            value = eval(arg)
        except:
            traceback.print_exc(file=sys.stderr)
            print('\nerror parsing argument "%s"' % (arg,), 
                     file=sys.stderr)
            return os.EX_DATAERR
        fn_args.append(value)

    # Create the transport
    if options.framed and options.unframed:
        op.error('cannot specify both --framed and --unframed')
    if options.url is not None:
        if options.host is not None:
            op.error('cannot specify both --url and --host')
        if not any([options.unframed, options.json]):
            op.error('can only specify --url with --unframed or --json')
        url = urlparse(options.url)
        parse_host_port(url[1], 80)
        transport = THttpClient.THttpClient(options.url)
    elif options.host is not None:
        host, port = parse_host_port(options.host, 9090)
        socket = TSSLSocket.TSSLSocket(host, port) if options.ssl \
                else TSocket.TSocket(host, port)
        if options.framed:
            transport = TTransport.TFramedTransport(socket)
        else:
            transport = TTransport.TBufferedTransport(socket)
    else:
        print('error: no --host or --url specified', file=sys.stderr)
        return os.EX_USAGE

    # Create the protocol and client
    if options.json:
        protocol = TJSONProtocol.TJSONProtocol(transport)
    elif options.compact:
        protocol = TCompactProtocol.TCompactProtocol(transport)
    # No explicit option about protocol is specified. Try to infer.
    elif options.framed or options.unframed:
        protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)
    else:
        protocol = THeaderProtocol.THeaderProtocol(socket)
        transport = protocol.trans
    transport.open()
    client = BoltSchedulerService.Client(protocol)

    # Call the function
    method = getattr(client, fn_name)
    ret = method(*fn_args)

    # Print the result
    pprint.pprint(ret, indent=2)


if __name__ == '__main__':
    rc = main(sys.argv)
    sys.exit(rc)
