#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

from .ttypes import *
from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastbinary
  if fastbinary.version < 2:
     fastbinary = None
     warnings.warn("Disabling fastbinary, need at least version 2")
except:
  fastbinary = None

all_structs = []
UTF8STRINGS = bool(1) or sys.version_info.major >= 3
from thrift.util.Decorators import *

class Iface:
  def submitSpans(self, span=None):
    """
    Parameters:
     - span
    """
    pass

  def getTrace(self, traceId=None):
    """
    Parameters:
     - traceId
    """
    pass

  def getTraceIds(self, startId=0, limit=100):
    """
    Parameters:
     - startId
     - limit
    """
    pass

  def consolidateTraceIds(self, traceIds=None):
    """
    Parameters:
     - traceIds
    """
    pass


class ContextIface:
  def submitSpans(self, handler_ctx, span=None):
    """
    Parameters:
     - span
    """
    pass

  def getTrace(self, handler_ctx, traceId=None):
    """
    Parameters:
     - traceId
    """
    pass

  def getTraceIds(self, handler_ctx, startId=0, limit=100):
    """
    Parameters:
     - startId
     - limit
    """
    pass

  def consolidateTraceIds(self, handler_ctx, traceIds=None):
    """
    Parameters:
     - traceIds
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def submitSpans(self, span=None):
    """
    Parameters:
     - span
    """
    self.send_submitSpans(span)
    self.recv_submitSpans()

  def send_submitSpans(self, span=None):
    self._oprot.writeMessageBegin('submitSpans', TMessageType.CALL, self._seqid)
    args = submitSpans_args()
    args.span = span
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_submitSpans(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = submitSpans_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def getTrace(self, traceId=None):
    """
    Parameters:
     - traceId
    """
    self.send_getTrace(traceId)
    return self.recv_getTrace()

  def send_getTrace(self, traceId=None):
    self._oprot.writeMessageBegin('getTrace', TMessageType.CALL, self._seqid)
    args = getTrace_args()
    args.traceId = traceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTrace(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTrace_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.e != None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrace failed: unknown result");

  def getTraceIds(self, startId=0, limit=100):
    """
    Parameters:
     - startId
     - limit
    """
    self.send_getTraceIds(startId, limit)
    return self.recv_getTraceIds()

  def send_getTraceIds(self, startId=0, limit=100):
    self._oprot.writeMessageBegin('getTraceIds', TMessageType.CALL, self._seqid)
    args = getTraceIds_args()
    args.startId = startId
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTraceIds(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTraceIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.e != None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTraceIds failed: unknown result");

  def consolidateTraceIds(self, traceIds=None):
    """
    Parameters:
     - traceIds
    """
    self.send_consolidateTraceIds(traceIds)
    self.recv_consolidateTraceIds()

  def send_consolidateTraceIds(self, traceIds=None):
    self._oprot.writeMessageBegin('consolidateTraceIds', TMessageType.CALL, self._seqid)
    args = consolidateTraceIds_args()
    args.traceIds = traceIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_consolidateTraceIds(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = consolidateTraceIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["submitSpans"] = Processor.process_submitSpans
    self._processMap["getTrace"] = Processor.process_getTrace
    self._processMap["getTraceIds"] = Processor.process_getTraceIds
    self._processMap["consolidateTraceIds"] = Processor.process_consolidateTraceIds

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_submitSpans(self, args, handler_ctx):
    result = submitSpans_result()
    try:
      self._handler.submitSpans(args.span)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'submitSpans', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'submitSpans', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getTrace(self, args, handler_ctx):
    result = getTrace_result()
    try:
      result.success = self._handler.getTrace(args.traceId)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getTrace', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getTrace', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getTraceIds(self, args, handler_ctx):
    result = getTraceIds_result()
    try:
      result.success = self._handler.getTraceIds(args.startId, args.limit)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getTraceIds', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getTraceIds', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_consolidateTraceIds(self, args, handler_ctx):
    result = consolidateTraceIds_result()
    try:
      self._handler.consolidateTraceIds(args.traceIds)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'consolidateTraceIds', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'consolidateTraceIds', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["submitSpans"] = ContextProcessor.process_submitSpans
    self._processMap["getTrace"] = ContextProcessor.process_getTrace
    self._processMap["getTraceIds"] = ContextProcessor.process_getTraceIds
    self._processMap["consolidateTraceIds"] = ContextProcessor.process_consolidateTraceIds

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_submitSpans(self, args, handler_ctx):
    result = submitSpans_result()
    try:
      self._handler.submitSpans(handler_ctx, args.span)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'submitSpans', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'submitSpans', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getTrace(self, args, handler_ctx):
    result = getTrace_result()
    try:
      result.success = self._handler.getTrace(handler_ctx, args.traceId)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getTrace', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getTrace', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_getTraceIds(self, args, handler_ctx):
    result = getTraceIds_result()
    try:
      result.success = self._handler.getTraceIds(handler_ctx, args.startId, args.limit)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getTraceIds', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getTraceIds', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_consolidateTraceIds(self, args, handler_ctx):
    result = consolidateTraceIds_result()
    try:
      self._handler.consolidateTraceIds(handler_ctx, args.traceIds)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'consolidateTraceIds', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'consolidateTraceIds', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

# HELPER FUNCTIONS AND STRUCTURES

class submitSpans_args:
  """
  Attributes:
   - span
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.span = []
          (_etype150, _size147) = iprot.readListBegin()
          if _size147 >= 0:
            for _i151 in six.moves.range(_size147):
              _elem152 = Span()
              _elem152.read(iprot)
              self.span.append(_elem152)
          else: 
            while iprot.peekList():
              _elem153 = Span()
              _elem153.read(iprot)
              self.span.append(_elem153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('submitSpans_args')
    if self.span != None:
      oprot.writeFieldBegin('span', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.span))
      for iter154 in self.span:
        iter154.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'span' in json_obj and json_obj['span'] is not None:
      self.span = []
      for _tmp_e155 in json_obj['span']:
        _struct156 = Span()
        _struct156.readFromJson(_tmp_e155, is_text=False)
        self.span.append(_struct156)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(submitSpans_args)
submitSpans_args.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'span', (TType.STRUCT,[Span, Span.thrift_spec, False]), None, 2, ), # 1
)

def submitSpans_args__init__(self, span=None,):
  self.span = span

submitSpans_args.__init__ = submitSpans_args__init__

class submitSpans_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('submitSpans_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(submitSpans_result)
submitSpans_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def submitSpans_result__init__(self, e=None,):
  self.e = e

submitSpans_result.__init__ = submitSpans_result__init__

class getTrace_args:
  """
  Attributes:
   - traceId
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.traceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getTrace_args')
    if self.traceId != None:
      oprot.writeFieldBegin('traceId', TType.I64, 1)
      oprot.writeI64(self.traceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'traceId' in json_obj and json_obj['traceId'] is not None:
      self.traceId = long(json_obj['traceId'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getTrace_args)
getTrace_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'traceId', None, None, 2, ), # 1
)

def getTrace_args__init__(self, traceId=None,):
  self.traceId = traceId

getTrace_args.__init__ = getTrace_args__init__

class getTrace_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype160, _size157) = iprot.readListBegin()
          if _size157 >= 0:
            for _i161 in six.moves.range(_size157):
              _elem162 = Span()
              _elem162.read(iprot)
              self.success.append(_elem162)
          else: 
            while iprot.peekList():
              _elem163 = Span()
              _elem163.read(iprot)
              self.success.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getTrace_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter164 in self.success:
        iter164.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'success' in json_obj and json_obj['success'] is not None:
      self.success = []
      for _tmp_e165 in json_obj['success']:
        _struct166 = Span()
        _struct166.readFromJson(_tmp_e165, is_text=False)
        self.success.append(_struct166)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getTrace_result)
getTrace_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.STRUCT,[Span, Span.thrift_spec, False]), None, 2, ), # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def getTrace_result__init__(self, success=None, e=None,):
  self.success = success
  self.e = e

getTrace_result.__init__ = getTrace_result__init__

class getTraceIds_args:
  """
  Attributes:
   - startId
   - limit
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.startId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getTraceIds_args')
    if self.startId != None:
      oprot.writeFieldBegin('startId', TType.I64, 1)
      oprot.writeI64(self.startId)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'startId' in json_obj and json_obj['startId'] is not None:
      self.startId = long(json_obj['startId'])
    if 'limit' in json_obj and json_obj['limit'] is not None:
      self.limit = json_obj['limit']
      if self.limit > 0x7fffffff or self.limit < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getTraceIds_args)
getTraceIds_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'startId', None, 0, 2, ), # 1
  (2, TType.I32, 'limit', None, 100, 2, ), # 2
)

def getTraceIds_args__init__(self, startId=getTraceIds_args.thrift_spec[1][4], limit=getTraceIds_args.thrift_spec[2][4],):
  self.startId = startId
  self.limit = limit

getTraceIds_args.__init__ = getTraceIds_args__init__

class getTraceIds_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype170, _size167) = iprot.readListBegin()
          if _size167 >= 0:
            for _i171 in six.moves.range(_size167):
              _elem172 = iprot.readI64()
              self.success.append(_elem172)
          else: 
            while iprot.peekList():
              _elem173 = iprot.readI64()
              self.success.append(_elem173)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('getTraceIds_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I64, len(self.success))
      for iter174 in self.success:
        oprot.writeI64(iter174)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'success' in json_obj and json_obj['success'] is not None:
      self.success = []
      for _tmp_e175 in json_obj['success']:
        self.success.append(_tmp_e175)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(getTraceIds_result)
getTraceIds_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.I64,None), None, 2, ), # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def getTraceIds_result__init__(self, success=None, e=None,):
  self.success = success
  self.e = e

getTraceIds_result.__init__ = getTraceIds_result__init__

class consolidateTraceIds_args:
  """
  Attributes:
   - traceIds
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.traceIds = []
          (_etype179, _size176) = iprot.readListBegin()
          if _size176 >= 0:
            for _i180 in six.moves.range(_size176):
              _elem181 = iprot.readI64()
              self.traceIds.append(_elem181)
          else: 
            while iprot.peekList():
              _elem182 = iprot.readI64()
              self.traceIds.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('consolidateTraceIds_args')
    if self.traceIds != None:
      oprot.writeFieldBegin('traceIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.traceIds))
      for iter183 in self.traceIds:
        oprot.writeI64(iter183)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'traceIds' in json_obj and json_obj['traceIds'] is not None:
      self.traceIds = []
      for _tmp_e184 in json_obj['traceIds']:
        self.traceIds.append(_tmp_e184)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(consolidateTraceIds_args)
consolidateTraceIds_args.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'traceIds', (TType.I64,None), None, 2, ), # 1
)

def consolidateTraceIds_args__init__(self, traceIds=None,):
  self.traceIds = traceIds

consolidateTraceIds_args.__init__ = consolidateTraceIds_args__init__

class consolidateTraceIds_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('consolidateTraceIds_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(consolidateTraceIds_result)
consolidateTraceIds_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def consolidateTraceIds_result__init__(self, e=None,):
  self.e = e

consolidateTraceIds_result.__init__ = consolidateTraceIds_result__init__

fix_spec(all_structs)
del all_structs

