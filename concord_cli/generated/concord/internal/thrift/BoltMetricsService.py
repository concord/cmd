#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

from .ttypes import *
from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastbinary
  if fastbinary.version < 2:
     fastbinary = None
     warnings.warn("Disabling fastbinary, need at least version 2")
except:
  fastbinary = None

all_structs = []
UTF8STRINGS = bool(1) or sys.version_info.major >= 3
from thrift.util.Decorators import *

class Iface:
  def gauge(self, name=None, val=None):
    """
    Parameters:
     - name
     - val
    """
    pass

  def timer(self, name=None, duration=None):
    """
    Parameters:
     - name
     - duration
    """
    pass

  def histogram(self, name=None, measure=None):
    """
    Parameters:
     - name
     - measure
    """
    pass

  def sum(self, name=None, counter=None):
    """
    Parameters:
     - name
     - counter
    """
    pass


class ContextIface:
  def gauge(self, handler_ctx, name=None, val=None):
    """
    Parameters:
     - name
     - val
    """
    pass

  def timer(self, handler_ctx, name=None, duration=None):
    """
    Parameters:
     - name
     - duration
    """
    pass

  def histogram(self, handler_ctx, name=None, measure=None):
    """
    Parameters:
     - name
     - measure
    """
    pass

  def sum(self, handler_ctx, name=None, counter=None):
    """
    Parameters:
     - name
     - counter
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def gauge(self, name=None, val=None):
    """
    Parameters:
     - name
     - val
    """
    self.send_gauge(name, val)
    self.recv_gauge()

  def send_gauge(self, name=None, val=None):
    self._oprot.writeMessageBegin('gauge', TMessageType.CALL, self._seqid)
    args = gauge_args()
    args.name = name
    args.val = val
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_gauge(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = gauge_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def timer(self, name=None, duration=None):
    """
    Parameters:
     - name
     - duration
    """
    self.send_timer(name, duration)
    self.recv_timer()

  def send_timer(self, name=None, duration=None):
    self._oprot.writeMessageBegin('timer', TMessageType.CALL, self._seqid)
    args = timer_args()
    args.name = name
    args.duration = duration
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timer(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = timer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def histogram(self, name=None, measure=None):
    """
    Parameters:
     - name
     - measure
    """
    self.send_histogram(name, measure)
    self.recv_histogram()

  def send_histogram(self, name=None, measure=None):
    self._oprot.writeMessageBegin('histogram', TMessageType.CALL, self._seqid)
    args = histogram_args()
    args.name = name
    args.measure = measure
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_histogram(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = histogram_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return

  def sum(self, name=None, counter=None):
    """
    Parameters:
     - name
     - counter
    """
    self.send_sum(name, counter)
    self.recv_sum()

  def send_sum(self, name=None, counter=None):
    self._oprot.writeMessageBegin('sum', TMessageType.CALL, self._seqid)
    args = sum_args()
    args.name = name
    args.counter = counter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sum(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sum_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.e != None:
      raise result.e
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["gauge"] = Processor.process_gauge
    self._processMap["timer"] = Processor.process_timer
    self._processMap["histogram"] = Processor.process_histogram
    self._processMap["sum"] = Processor.process_sum

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_gauge(self, args, handler_ctx):
    result = gauge_result()
    try:
      self._handler.gauge(args.name, args.val)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'gauge', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'gauge', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_timer(self, args, handler_ctx):
    result = timer_result()
    try:
      self._handler.timer(args.name, args.duration)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'timer', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'timer', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_histogram(self, args, handler_ctx):
    result = histogram_result()
    try:
      self._handler.histogram(args.name, args.measure)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'histogram', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'histogram', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_sum(self, args, handler_ctx):
    result = sum_result()
    try:
      self._handler.sum(args.name, args.counter)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'sum', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'sum', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["gauge"] = ContextProcessor.process_gauge
    self._processMap["timer"] = ContextProcessor.process_timer
    self._processMap["histogram"] = ContextProcessor.process_histogram
    self._processMap["sum"] = ContextProcessor.process_sum

  @process_main()
  def process(self,): pass

  @process_method(oneway=False)
  def process_gauge(self, args, handler_ctx):
    result = gauge_result()
    try:
      self._handler.gauge(handler_ctx, args.name, args.val)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'gauge', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'gauge', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_timer(self, args, handler_ctx):
    result = timer_result()
    try:
      self._handler.timer(handler_ctx, args.name, args.duration)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'timer', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'timer', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_histogram(self, args, handler_ctx):
    result = histogram_result()
    try:
      self._handler.histogram(handler_ctx, args.name, args.measure)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'histogram', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'histogram', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(oneway=False)
  def process_sum(self, args, handler_ctx):
    result = sum_result()
    try:
      self._handler.sum(handler_ctx, args.name, args.counter)
    except BoltError as exc0:
      self._event_handler.handlerException(handler_ctx, 'sum', exc0)
      result.e = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'sum', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

# HELPER FUNCTIONS AND STRUCTURES

class gauge_args:
  """
  Attributes:
   - name
   - val
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.val = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('gauge_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.val != None:
      oprot.writeFieldBegin('val', TType.I64, 2)
      oprot.writeI64(self.val)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'val' in json_obj and json_obj['val'] is not None:
      self.val = long(json_obj['val'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(gauge_args)
gauge_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I64, 'val', None, None, 2, ), # 2
)

def gauge_args__init__(self, name=None, val=None,):
  self.name = name
  self.val = val

gauge_args.__init__ = gauge_args__init__

class gauge_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('gauge_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(gauge_result)
gauge_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def gauge_result__init__(self, e=None,):
  self.e = e

gauge_result.__init__ = gauge_result__init__

class timer_args:
  """
  Attributes:
   - name
   - duration
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.duration = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('timer_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.duration != None:
      oprot.writeFieldBegin('duration', TType.I64, 2)
      oprot.writeI64(self.duration)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'duration' in json_obj and json_obj['duration'] is not None:
      self.duration = long(json_obj['duration'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(timer_args)
timer_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I64, 'duration', None, None, 2, ), # 2
)

def timer_args__init__(self, name=None, duration=None,):
  self.name = name
  self.duration = duration

timer_args.__init__ = timer_args__init__

class timer_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('timer_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(timer_result)
timer_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def timer_result__init__(self, e=None,):
  self.e = e

timer_result.__init__ = timer_result__init__

class histogram_args:
  """
  Attributes:
   - name
   - measure
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.measure = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('histogram_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.measure != None:
      oprot.writeFieldBegin('measure', TType.I64, 2)
      oprot.writeI64(self.measure)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'measure' in json_obj and json_obj['measure'] is not None:
      self.measure = long(json_obj['measure'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(histogram_args)
histogram_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I64, 'measure', None, None, 2, ), # 2
)

def histogram_args__init__(self, name=None, measure=None,):
  self.name = name
  self.measure = measure

histogram_args.__init__ = histogram_args__init__

class histogram_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('histogram_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(histogram_result)
histogram_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def histogram_result__init__(self, e=None,):
  self.e = e

histogram_result.__init__ = histogram_result__init__

class sum_args:
  """
  Attributes:
   - name
   - counter
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.counter = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('sum_args')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.counter != None:
      oprot.writeFieldBegin('counter', TType.I64, 2)
      oprot.writeI64(self.counter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'counter' in json_obj and json_obj['counter'] is not None:
      self.counter = long(json_obj['counter'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(sum_args)
sum_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I64, 'counter', None, None, 2, ), # 2
)

def sum_args__init__(self, name=None, counter=None,):
  self.name = name
  self.counter = counter

sum_args.__init__ = sum_args__init__

class sum_result:
  """
  Attributes:
   - e
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = BoltError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('sum_result')
    if self.e != None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'e' in json_obj and json_obj['e'] is not None:
      self.e = BoltError()
      self.e.readFromJson(json_obj['e'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(sum_result)
sum_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'e', [BoltError, BoltError.thrift_spec, False], None, 2, ), # 1
)

def sum_result__init__(self, e=None,):
  self.e = e

sum_result.__init__ = sum_result__init__

fix_spec(all_structs)
del all_structs

