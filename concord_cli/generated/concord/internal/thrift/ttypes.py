#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastbinary
  if fastbinary.version < 2:
     fastbinary = None
     warnings.warn("Disabling fastbinary, need at least version 2")
except:
  fastbinary = None
all_structs = []
UTF8STRINGS = bool(1) or sys.version_info.major >= 3

class BackPressure:
  NONE = 0
  ENQUEUE = 1
  DROP_HEAD = 2
  DROP_TAIL = 3
  BLOCK_SENDER = 4

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "ENQUEUE",
    2: "DROP_HEAD",
    3: "DROP_TAIL",
    4: "BLOCK_SENDER",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "ENQUEUE": 1,
    "DROP_HEAD": 2,
    "DROP_TAIL": 3,
    "BLOCK_SENDER": 4,
  }

class StreamGrouping:
  ROUND_ROBIN = 0
  SHUFFLE = 1
  GROUP_BY = 2
  LOCAL = 3
  CUSTOM = 100

  _VALUES_TO_NAMES = {
    0: "ROUND_ROBIN",
    1: "SHUFFLE",
    2: "GROUP_BY",
    3: "LOCAL",
    100: "CUSTOM",
  }

  _NAMES_TO_VALUES = {
    "ROUND_ROBIN": 0,
    "SHUFFLE": 1,
    "GROUP_BY": 2,
    "LOCAL": 3,
    "CUSTOM": 100,
  }

class Signal:
  START = 0
  ACTIVE = 1
  INACTIVE = 2
  SHUTDOWN = 3
  KILL = 4

  _VALUES_TO_NAMES = {
    0: "START",
    1: "ACTIVE",
    2: "INACTIVE",
    3: "SHUTDOWN",
    4: "KILL",
  }

  _NAMES_TO_VALUES = {
    "START": 0,
    "ACTIVE": 1,
    "INACTIVE": 2,
    "SHUTDOWN": 3,
    "KILL": 4,
  }

class RecordFlags:
  CLIENT_RECORD = 1
  FRAMEWORK_RECORD = 2

  _VALUES_TO_NAMES = {
    1: "CLIENT_RECORD",
    2: "FRAMEWORK_RECORD",
  }

  _NAMES_TO_VALUES = {
    "CLIENT_RECORD": 1,
    "FRAMEWORK_RECORD": 2,
  }

class AnnotationType:
  CLIENT_SEND = 0
  CLIENT_RECV = 1
  SERVER_SEND = 2
  SERVER_RECV = 3

  _VALUES_TO_NAMES = {
    0: "CLIENT_SEND",
    1: "CLIENT_RECV",
    2: "SERVER_SEND",
    3: "SERVER_RECV",
  }

  _NAMES_TO_VALUES = {
    "CLIENT_SEND": 0,
    "CLIENT_RECV": 1,
    "SERVER_SEND": 2,
    "SERVER_RECV": 3,
  }

class BoltError(TException):
  """
  Attributes:
   - reason
   - context
   - time
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.reason = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.context = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('BoltError')
    if self.reason != None:
      oprot.writeFieldBegin('reason', TType.STRING, 1)
      oprot.writeString(self.reason.encode('utf-8')) if UTF8STRINGS and not isinstance(self.reason, bytes) else oprot.writeString(self.reason)
      oprot.writeFieldEnd()
    if self.context != None:
      oprot.writeFieldBegin('context', TType.STRING, 2)
      oprot.writeString(self.context.encode('utf-8')) if UTF8STRINGS and not isinstance(self.context, bytes) else oprot.writeString(self.context)
      oprot.writeFieldEnd()
    if self.time != None:
      oprot.writeFieldBegin('time', TType.I64, 3)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'reason' in json_obj and json_obj['reason'] is not None:
      self.reason = json_obj['reason']
    if 'context' in json_obj and json_obj['context'] is not None:
      self.context = json_obj['context']
    if 'time' in json_obj and json_obj['time'] is not None:
      self.time = long(json_obj['time'])

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Endpoint:
  """
  Attributes:
   - ip
   - port
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.port = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('Endpoint')
    if self.ip != None:
      oprot.writeFieldBegin('ip', TType.STRING, 1)
      oprot.writeString(self.ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ip, bytes) else oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.port != None:
      oprot.writeFieldBegin('port', TType.I16, 2)
      oprot.writeI16(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'ip' in json_obj and json_obj['ip'] is not None:
      self.ip = json_obj['ip']
    if 'port' in json_obj and json_obj['port'] is not None:
      self.port = json_obj['port']
      if self.port > 0x7fff or self.port < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamMetadata:
  """
  Attributes:
   - name
   - grouping
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.grouping = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('StreamMetadata')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.grouping != None:
      oprot.writeFieldBegin('grouping', TType.I32, 2)
      oprot.writeI32(self.grouping)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'grouping' in json_obj and json_obj['grouping'] is not None:
      self.grouping = json_obj['grouping']
      if not self.grouping in StreamGrouping._VALUES_TO_NAMES:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'enum exceeds limit')

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ComputationMetadata:
  """
  Attributes:
   - name
   - taskId
   - istreams
   - ostreams
   - proxyEndpoint
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.taskId = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.istreams = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = StreamMetadata()
              _elem5.read(iprot)
              self.istreams.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = StreamMetadata()
              _elem6.read(iprot)
              self.istreams.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ostreams = []
          (_etype10, _size7) = iprot.readListBegin()
          if _size7 >= 0:
            for _i11 in six.moves.range(_size7):
              _elem12 = StreamMetadata()
              _elem12.read(iprot)
              self.ostreams.append(_elem12)
          else: 
            while iprot.peekList():
              _elem13 = StreamMetadata()
              _elem13.read(iprot)
              self.ostreams.append(_elem13)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.proxyEndpoint = Endpoint()
          self.proxyEndpoint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('ComputationMetadata')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.taskId != None:
      oprot.writeFieldBegin('taskId', TType.STRING, 2)
      oprot.writeString(self.taskId.encode('utf-8')) if UTF8STRINGS and not isinstance(self.taskId, bytes) else oprot.writeString(self.taskId)
      oprot.writeFieldEnd()
    if self.istreams != None:
      oprot.writeFieldBegin('istreams', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.istreams))
      for iter14 in self.istreams:
        iter14.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ostreams != None:
      oprot.writeFieldBegin('ostreams', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.ostreams))
      for iter15 in self.ostreams:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.proxyEndpoint != None:
      oprot.writeFieldBegin('proxyEndpoint', TType.STRUCT, 5)
      self.proxyEndpoint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'taskId' in json_obj and json_obj['taskId'] is not None:
      self.taskId = json_obj['taskId']
    if 'istreams' in json_obj and json_obj['istreams'] is not None:
      self.istreams = []
      for _tmp_e16 in json_obj['istreams']:
        _struct17 = StreamMetadata()
        _struct17.readFromJson(_tmp_e16, is_text=False)
        self.istreams.append(_struct17)
    if 'ostreams' in json_obj and json_obj['ostreams'] is not None:
      self.ostreams = []
      for _tmp_e18 in json_obj['ostreams']:
        _struct19 = StreamMetadata()
        _struct19.readFromJson(_tmp_e18, is_text=False)
        self.ostreams.append(_struct19)
    if 'proxyEndpoint' in json_obj and json_obj['proxyEndpoint'] is not None:
      self.proxyEndpoint = Endpoint()
      self.proxyEndpoint.readFromJson(json_obj['proxyEndpoint'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExecutorTaskInfoHelper:
  """
  Attributes:
   - frameworkLoggingLevel
   - user
   - frameworkVModule
   - scheduler
   - proxy
   - client
   - traceAggregator
   - execName
   - folder
   - computationAliasName
   - clientArguments
   - environmentExtra
   - dockerContainer
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.frameworkLoggingLevel = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.frameworkVModule = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.scheduler = Endpoint()
          self.scheduler.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.proxy = Endpoint()
          self.proxy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.client = Endpoint()
          self.client.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.traceAggregator = Endpoint()
          self.traceAggregator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.execName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.folder = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.computationAliasName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.clientArguments = []
          (_etype23, _size20) = iprot.readListBegin()
          if _size20 >= 0:
            for _i24 in six.moves.range(_size20):
              _elem25 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.clientArguments.append(_elem25)
          else: 
            while iprot.peekList():
              _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.clientArguments.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.environmentExtra = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in six.moves.range(_size27):
              _elem32 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.environmentExtra.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.environmentExtra.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.dockerContainer = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('ExecutorTaskInfoHelper')
    if self.frameworkLoggingLevel != None:
      oprot.writeFieldBegin('frameworkLoggingLevel', TType.I32, 1)
      oprot.writeI32(self.frameworkLoggingLevel)
      oprot.writeFieldEnd()
    if self.user != None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user.encode('utf-8')) if UTF8STRINGS and not isinstance(self.user, bytes) else oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.frameworkVModule != None:
      oprot.writeFieldBegin('frameworkVModule', TType.STRING, 3)
      oprot.writeString(self.frameworkVModule.encode('utf-8')) if UTF8STRINGS and not isinstance(self.frameworkVModule, bytes) else oprot.writeString(self.frameworkVModule)
      oprot.writeFieldEnd()
    if self.scheduler != None:
      oprot.writeFieldBegin('scheduler', TType.STRUCT, 4)
      self.scheduler.write(oprot)
      oprot.writeFieldEnd()
    if self.proxy != None:
      oprot.writeFieldBegin('proxy', TType.STRUCT, 5)
      self.proxy.write(oprot)
      oprot.writeFieldEnd()
    if self.client != None:
      oprot.writeFieldBegin('client', TType.STRUCT, 6)
      self.client.write(oprot)
      oprot.writeFieldEnd()
    if self.traceAggregator != None:
      oprot.writeFieldBegin('traceAggregator', TType.STRUCT, 7)
      self.traceAggregator.write(oprot)
      oprot.writeFieldEnd()
    if self.execName != None:
      oprot.writeFieldBegin('execName', TType.STRING, 8)
      oprot.writeString(self.execName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.execName, bytes) else oprot.writeString(self.execName)
      oprot.writeFieldEnd()
    if self.folder != None:
      oprot.writeFieldBegin('folder', TType.STRING, 9)
      oprot.writeString(self.folder.encode('utf-8')) if UTF8STRINGS and not isinstance(self.folder, bytes) else oprot.writeString(self.folder)
      oprot.writeFieldEnd()
    if self.computationAliasName != None:
      oprot.writeFieldBegin('computationAliasName', TType.STRING, 10)
      oprot.writeString(self.computationAliasName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.computationAliasName, bytes) else oprot.writeString(self.computationAliasName)
      oprot.writeFieldEnd()
    if self.clientArguments != None:
      oprot.writeFieldBegin('clientArguments', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.clientArguments))
      for iter34 in self.clientArguments:
        oprot.writeString(iter34.encode('utf-8')) if UTF8STRINGS and not isinstance(iter34, bytes) else oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.environmentExtra != None:
      oprot.writeFieldBegin('environmentExtra', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.environmentExtra))
      for iter35 in self.environmentExtra:
        oprot.writeString(iter35.encode('utf-8')) if UTF8STRINGS and not isinstance(iter35, bytes) else oprot.writeString(iter35)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dockerContainer != None:
      oprot.writeFieldBegin('dockerContainer', TType.STRING, 13)
      oprot.writeString(self.dockerContainer.encode('utf-8')) if UTF8STRINGS and not isinstance(self.dockerContainer, bytes) else oprot.writeString(self.dockerContainer)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'frameworkLoggingLevel' in json_obj and json_obj['frameworkLoggingLevel'] is not None:
      self.frameworkLoggingLevel = json_obj['frameworkLoggingLevel']
      if self.frameworkLoggingLevel > 0x7fffffff or self.frameworkLoggingLevel < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'user' in json_obj and json_obj['user'] is not None:
      self.user = json_obj['user']
    if 'frameworkVModule' in json_obj and json_obj['frameworkVModule'] is not None:
      self.frameworkVModule = json_obj['frameworkVModule']
    if 'scheduler' in json_obj and json_obj['scheduler'] is not None:
      self.scheduler = Endpoint()
      self.scheduler.readFromJson(json_obj['scheduler'], is_text=False)
    if 'proxy' in json_obj and json_obj['proxy'] is not None:
      self.proxy = Endpoint()
      self.proxy.readFromJson(json_obj['proxy'], is_text=False)
    if 'client' in json_obj and json_obj['client'] is not None:
      self.client = Endpoint()
      self.client.readFromJson(json_obj['client'], is_text=False)
    if 'traceAggregator' in json_obj and json_obj['traceAggregator'] is not None:
      self.traceAggregator = Endpoint()
      self.traceAggregator.readFromJson(json_obj['traceAggregator'], is_text=False)
    if 'execName' in json_obj and json_obj['execName'] is not None:
      self.execName = json_obj['execName']
    if 'folder' in json_obj and json_obj['folder'] is not None:
      self.folder = json_obj['folder']
    if 'computationAliasName' in json_obj and json_obj['computationAliasName'] is not None:
      self.computationAliasName = json_obj['computationAliasName']
    if 'clientArguments' in json_obj and json_obj['clientArguments'] is not None:
      self.clientArguments = []
      for _tmp_e36 in json_obj['clientArguments']:
        self.clientArguments.append(_tmp_e36)
    if 'environmentExtra' in json_obj and json_obj['environmentExtra'] is not None:
      self.environmentExtra = []
      for _tmp_e37 in json_obj['environmentExtra']:
        self.environmentExtra.append(_tmp_e37)
    if 'dockerContainer' in json_obj and json_obj['dockerContainer'] is not None:
      self.dockerContainer = json_obj['dockerContainer']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PhysicalComputationMetdata:
  """
  Attributes:
   - taskId
   - slaveId
   - cpus
   - mem
   - disk
   - taskHelper
   - needsReconciliation
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.slaveId = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.cpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mem = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.disk = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.taskHelper = ExecutorTaskInfoHelper()
          self.taskHelper.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.needsReconciliation = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('PhysicalComputationMetdata')
    if self.taskId != None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId.encode('utf-8')) if UTF8STRINGS and not isinstance(self.taskId, bytes) else oprot.writeString(self.taskId)
      oprot.writeFieldEnd()
    if self.slaveId != None:
      oprot.writeFieldBegin('slaveId', TType.STRING, 2)
      oprot.writeString(self.slaveId.encode('utf-8')) if UTF8STRINGS and not isinstance(self.slaveId, bytes) else oprot.writeString(self.slaveId)
      oprot.writeFieldEnd()
    if self.cpus != None:
      oprot.writeFieldBegin('cpus', TType.DOUBLE, 3)
      oprot.writeDouble(self.cpus)
      oprot.writeFieldEnd()
    if self.mem != None:
      oprot.writeFieldBegin('mem', TType.I32, 4)
      oprot.writeI32(self.mem)
      oprot.writeFieldEnd()
    if self.disk != None:
      oprot.writeFieldBegin('disk', TType.I32, 5)
      oprot.writeI32(self.disk)
      oprot.writeFieldEnd()
    if self.taskHelper != None:
      oprot.writeFieldBegin('taskHelper', TType.STRUCT, 6)
      self.taskHelper.write(oprot)
      oprot.writeFieldEnd()
    if self.needsReconciliation != None:
      oprot.writeFieldBegin('needsReconciliation', TType.BOOL, 7)
      oprot.writeBool(self.needsReconciliation)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'taskId' in json_obj and json_obj['taskId'] is not None:
      self.taskId = json_obj['taskId']
    if 'slaveId' in json_obj and json_obj['slaveId'] is not None:
      self.slaveId = json_obj['slaveId']
    if 'cpus' in json_obj and json_obj['cpus'] is not None:
      self.cpus = float(json_obj['cpus'])
    if 'mem' in json_obj and json_obj['mem'] is not None:
      self.mem = json_obj['mem']
      if self.mem > 0x7fffffff or self.mem < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'disk' in json_obj and json_obj['disk'] is not None:
      self.disk = json_obj['disk']
      if self.disk > 0x7fffffff or self.disk < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'taskHelper' in json_obj and json_obj['taskHelper'] is not None:
      self.taskHelper = ExecutorTaskInfoHelper()
      self.taskHelper.readFromJson(json_obj['taskHelper'], is_text=False)
    if 'needsReconciliation' in json_obj and json_obj['needsReconciliation'] is not None:
      self.needsReconciliation = json_obj['needsReconciliation']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PhysicalComputationLayout:
  """
  Attributes:
   - name
   - istreams
   - ostreams
   - nodes
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.istreams = []
          (_etype41, _size38) = iprot.readListBegin()
          if _size38 >= 0:
            for _i42 in six.moves.range(_size38):
              _elem43 = StreamMetadata()
              _elem43.read(iprot)
              self.istreams.append(_elem43)
          else: 
            while iprot.peekList():
              _elem44 = StreamMetadata()
              _elem44.read(iprot)
              self.istreams.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ostreams = []
          (_etype48, _size45) = iprot.readListBegin()
          if _size45 >= 0:
            for _i49 in six.moves.range(_size45):
              _elem50 = StreamMetadata()
              _elem50.read(iprot)
              self.ostreams.append(_elem50)
          else: 
            while iprot.peekList():
              _elem51 = StreamMetadata()
              _elem51.read(iprot)
              self.ostreams.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype55, _size52) = iprot.readListBegin()
          if _size52 >= 0:
            for _i56 in six.moves.range(_size52):
              _elem57 = PhysicalComputationMetdata()
              _elem57.read(iprot)
              self.nodes.append(_elem57)
          else: 
            while iprot.peekList():
              _elem58 = PhysicalComputationMetdata()
              _elem58.read(iprot)
              self.nodes.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('PhysicalComputationLayout')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.istreams != None:
      oprot.writeFieldBegin('istreams', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.istreams))
      for iter59 in self.istreams:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ostreams != None:
      oprot.writeFieldBegin('ostreams', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.ostreams))
      for iter60 in self.ostreams:
        iter60.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter61 in self.nodes:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'istreams' in json_obj and json_obj['istreams'] is not None:
      self.istreams = []
      for _tmp_e62 in json_obj['istreams']:
        _struct63 = StreamMetadata()
        _struct63.readFromJson(_tmp_e62, is_text=False)
        self.istreams.append(_struct63)
    if 'ostreams' in json_obj and json_obj['ostreams'] is not None:
      self.ostreams = []
      for _tmp_e64 in json_obj['ostreams']:
        _struct65 = StreamMetadata()
        _struct65.readFromJson(_tmp_e64, is_text=False)
        self.ostreams.append(_struct65)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = []
      for _tmp_e66 in json_obj['nodes']:
        _struct67 = PhysicalComputationMetdata()
        _struct67.readFromJson(_tmp_e66, is_text=False)
        self.nodes.append(_struct67)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SchedulerMetadata:
  """
  Attributes:
   - endpoint
   - version
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.endpoint = Endpoint()
          self.endpoint.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('SchedulerMetadata')
    if self.endpoint != None:
      oprot.writeFieldBegin('endpoint', TType.STRUCT, 1)
      self.endpoint.write(oprot)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I32, 2)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'endpoint' in json_obj and json_obj['endpoint'] is not None:
      self.endpoint = Endpoint()
      self.endpoint.readFromJson(json_obj['endpoint'], is_text=False)
    if 'version' in json_obj and json_obj['version'] is not None:
      self.version = json_obj['version']
      if self.version > 0x7fffffff or self.version < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TopologyMetadata:
  """
  Attributes:
   - version
   - hash
   - computations
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hash = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.computations = {}
          (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin() 
          if _size68 >= 0:
            for _i72 in six.moves.range(_size68):
              _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val74 = PhysicalComputationLayout()
              _val74.read(iprot)
              self.computations[_key73] = _val74
          else: 
            while iprot.peekMap():
              _key75 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val76 = PhysicalComputationLayout()
              _val76.read(iprot)
              self.computations[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('TopologyMetadata')
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.hash != None:
      oprot.writeFieldBegin('hash', TType.STRING, 2)
      oprot.writeString(self.hash.encode('utf-8')) if UTF8STRINGS and not isinstance(self.hash, bytes) else oprot.writeString(self.hash)
      oprot.writeFieldEnd()
    if self.computations != None:
      oprot.writeFieldBegin('computations', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.computations))
      for kiter77,viter78 in self.computations.items():
        oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
        viter78.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'version' in json_obj and json_obj['version'] is not None:
      self.version = json_obj['version']
      if self.version > 0x7fffffff or self.version < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'hash' in json_obj and json_obj['hash'] is not None:
      self.hash = json_obj['hash']
    if 'computations' in json_obj and json_obj['computations'] is not None:
      self.computations = {}
      for _tmp_k79, _tmp_v80 in json_obj['computations'].items():
        _tmp_kp81 = _tmp_k79
        _struct82 = PhysicalComputationLayout()
        _struct82.readFromJson(_tmp_v80, is_text=False)
        self.computations[_tmp_kp81] = _struct82

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordMetadata:
  """
  Attributes:
   - traceId
   - sourceSpanId
   - flags
   - stream
   - timestamp
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.traceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.sourceSpanId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.flags = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.stream = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('RecordMetadata')
    if self.traceId != None:
      oprot.writeFieldBegin('traceId', TType.I64, 1)
      oprot.writeI64(self.traceId)
      oprot.writeFieldEnd()
    if self.sourceSpanId != None:
      oprot.writeFieldBegin('sourceSpanId', TType.I64, 2)
      oprot.writeI64(self.sourceSpanId)
      oprot.writeFieldEnd()
    if self.flags != None:
      oprot.writeFieldBegin('flags', TType.I32, 3)
      oprot.writeI32(self.flags)
      oprot.writeFieldEnd()
    if self.stream != None:
      oprot.writeFieldBegin('stream', TType.I64, 4)
      oprot.writeI64(self.stream)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'traceId' in json_obj and json_obj['traceId'] is not None:
      self.traceId = long(json_obj['traceId'])
    if 'sourceSpanId' in json_obj and json_obj['sourceSpanId'] is not None:
      self.sourceSpanId = long(json_obj['sourceSpanId'])
    if 'flags' in json_obj and json_obj['flags'] is not None:
      self.flags = json_obj['flags']
      if self.flags > 0x7fffffff or self.flags < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'stream' in json_obj and json_obj['stream'] is not None:
      self.stream = long(json_obj['stream'])
    if 'timestamp' in json_obj and json_obj['timestamp'] is not None:
      self.timestamp = long(json_obj['timestamp'])

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Record:
  """
  Attributes:
   - meta
   - time
   - key
   - data
   - userStream
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.meta = RecordMetadata()
          self.meta.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.userStream = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('Record')
    if self.meta != None:
      oprot.writeFieldBegin('meta', TType.STRUCT, 1)
      self.meta.write(oprot)
      oprot.writeFieldEnd()
    if self.time != None:
      oprot.writeFieldBegin('time', TType.I64, 2)
      oprot.writeI64(self.time)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 4)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.userStream != None:
      oprot.writeFieldBegin('userStream', TType.STRING, 5)
      oprot.writeString(self.userStream)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'meta' in json_obj and json_obj['meta'] is not None:
      self.meta = RecordMetadata()
      self.meta.readFromJson(json_obj['meta'], is_text=False)
    if 'time' in json_obj and json_obj['time'] is not None:
      self.time = long(json_obj['time'])
    if 'key' in json_obj and json_obj['key'] is not None:
      self.key = json_obj['key']
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = json_obj['data']
    if 'userStream' in json_obj and json_obj['userStream'] is not None:
      self.userStream = json_obj['userStream']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ComputationTx:
  """
  Attributes:
   - id
   - records
   - timers
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype86, _size83) = iprot.readListBegin()
          if _size83 >= 0:
            for _i87 in six.moves.range(_size83):
              _elem88 = Record()
              _elem88.read(iprot)
              self.records.append(_elem88)
          else: 
            while iprot.peekList():
              _elem89 = Record()
              _elem89.read(iprot)
              self.records.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.timers = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin() 
          if _size90 >= 0:
            for _i94 in six.moves.range(_size90):
              _key95 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val96 = iprot.readI64()
              self.timers[_key95] = _val96
          else: 
            while iprot.peekMap():
              _key97 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val98 = iprot.readI64()
              self.timers[_key97] = _val98
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('ComputationTx')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.records != None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.records))
      for iter99 in self.records:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timers != None:
      oprot.writeFieldBegin('timers', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.timers))
      for kiter100,viter101 in self.timers.items():
        oprot.writeString(kiter100.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter100, bytes) else oprot.writeString(kiter100)
        oprot.writeI64(viter101)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'id' in json_obj and json_obj['id'] is not None:
      self.id = long(json_obj['id'])
    if 'records' in json_obj and json_obj['records'] is not None:
      self.records = []
      for _tmp_e102 in json_obj['records']:
        _struct103 = Record()
        _struct103.readFromJson(_tmp_e102, is_text=False)
        self.records.append(_struct103)
    if 'timers' in json_obj and json_obj['timers'] is not None:
      self.timers = {}
      for _tmp_k104, _tmp_v105 in json_obj['timers'].items():
        _tmp_kp106 = _tmp_k104
        self.timers[_tmp_kp106] = _tmp_v105

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RichStream:
  """
  Attributes:
   - stream
   - computationName
   - endpoints
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stream = StreamMetadata()
          self.stream.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.computationName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.endpoints = []
          (_etype110, _size107) = iprot.readListBegin()
          if _size107 >= 0:
            for _i111 in six.moves.range(_size107):
              _elem112 = Endpoint()
              _elem112.read(iprot)
              self.endpoints.append(_elem112)
          else: 
            while iprot.peekList():
              _elem113 = Endpoint()
              _elem113.read(iprot)
              self.endpoints.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('RichStream')
    if self.stream != None:
      oprot.writeFieldBegin('stream', TType.STRUCT, 1)
      self.stream.write(oprot)
      oprot.writeFieldEnd()
    if self.computationName != None:
      oprot.writeFieldBegin('computationName', TType.STRING, 2)
      oprot.writeString(self.computationName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.computationName, bytes) else oprot.writeString(self.computationName)
      oprot.writeFieldEnd()
    if self.endpoints != None:
      oprot.writeFieldBegin('endpoints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.endpoints))
      for iter114 in self.endpoints:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'stream' in json_obj and json_obj['stream'] is not None:
      self.stream = StreamMetadata()
      self.stream.readFromJson(json_obj['stream'], is_text=False)
    if 'computationName' in json_obj and json_obj['computationName'] is not None:
      self.computationName = json_obj['computationName']
    if 'endpoints' in json_obj and json_obj['endpoints'] is not None:
      self.endpoints = []
      for _tmp_e115 in json_obj['endpoints']:
        _struct116 = Endpoint()
        _struct116.readFromJson(_tmp_e115, is_text=False)
        self.endpoints.append(_struct116)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BoltComputationRequest:
  """
  Attributes:
   - name
   - instances
   - cpus
   - mem
   - disk
   - taskHelper
   - forceUpdateBinary
   - slug
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.instances = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.cpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.mem = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.disk = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.taskHelper = ExecutorTaskInfoHelper()
          self.taskHelper.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.forceUpdateBinary = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.slug = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('BoltComputationRequest')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.instances != None:
      oprot.writeFieldBegin('instances', TType.I64, 2)
      oprot.writeI64(self.instances)
      oprot.writeFieldEnd()
    if self.cpus != None:
      oprot.writeFieldBegin('cpus', TType.DOUBLE, 3)
      oprot.writeDouble(self.cpus)
      oprot.writeFieldEnd()
    if self.mem != None:
      oprot.writeFieldBegin('mem', TType.I64, 4)
      oprot.writeI64(self.mem)
      oprot.writeFieldEnd()
    if self.disk != None:
      oprot.writeFieldBegin('disk', TType.I64, 5)
      oprot.writeI64(self.disk)
      oprot.writeFieldEnd()
    if self.taskHelper != None:
      oprot.writeFieldBegin('taskHelper', TType.STRUCT, 6)
      self.taskHelper.write(oprot)
      oprot.writeFieldEnd()
    if self.forceUpdateBinary != None:
      oprot.writeFieldBegin('forceUpdateBinary', TType.BOOL, 7)
      oprot.writeBool(self.forceUpdateBinary)
      oprot.writeFieldEnd()
    if self.slug != None:
      oprot.writeFieldBegin('slug', TType.STRING, 8)
      oprot.writeString(self.slug)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'instances' in json_obj and json_obj['instances'] is not None:
      self.instances = long(json_obj['instances'])
    if 'cpus' in json_obj and json_obj['cpus'] is not None:
      self.cpus = float(json_obj['cpus'])
    if 'mem' in json_obj and json_obj['mem'] is not None:
      self.mem = long(json_obj['mem'])
    if 'disk' in json_obj and json_obj['disk'] is not None:
      self.disk = long(json_obj['disk'])
    if 'taskHelper' in json_obj and json_obj['taskHelper'] is not None:
      self.taskHelper = ExecutorTaskInfoHelper()
      self.taskHelper.readFromJson(json_obj['taskHelper'], is_text=False)
    if 'forceUpdateBinary' in json_obj and json_obj['forceUpdateBinary'] is not None:
      self.forceUpdateBinary = json_obj['forceUpdateBinary']
    if 'slug' in json_obj and json_obj['slug'] is not None:
      self.slug = json_obj['slug']

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Annotation:
  """
  Attributes:
   - timestamp
   - type
   - key
   - value
   - host
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.host = Endpoint()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('Annotation')
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key.encode('utf-8')) if UTF8STRINGS and not isinstance(self.key, bytes) else oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 5)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'timestamp' in json_obj and json_obj['timestamp'] is not None:
      self.timestamp = long(json_obj['timestamp'])
    if 'type' in json_obj and json_obj['type'] is not None:
      self.type = json_obj['type']
      if not self.type in AnnotationType._VALUES_TO_NAMES:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'enum exceeds limit')
    if 'key' in json_obj and json_obj['key'] is not None:
      self.key = json_obj['key']
    if 'value' in json_obj and json_obj['value'] is not None:
      self.value = json_obj['value']
    if 'host' in json_obj and json_obj['host'] is not None:
      self.host = Endpoint()
      self.host.readFromJson(json_obj['host'], is_text=False)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Span:
  """
  Attributes:
   - traceId
   - id
   - parentId
   - name
   - annotations
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.traceId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.parentId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.annotations = []
          (_etype120, _size117) = iprot.readListBegin()
          if _size117 >= 0:
            for _i121 in six.moves.range(_size117):
              _elem122 = Annotation()
              _elem122.read(iprot)
              self.annotations.append(_elem122)
          else: 
            while iprot.peekList():
              _elem123 = Annotation()
              _elem123.read(iprot)
              self.annotations.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('Span')
    if self.traceId != None:
      oprot.writeFieldBegin('traceId', TType.I64, 1)
      oprot.writeI64(self.traceId)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.parentId != None:
      oprot.writeFieldBegin('parentId', TType.I64, 3)
      oprot.writeI64(self.parentId)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.annotations != None:
      oprot.writeFieldBegin('annotations', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.annotations))
      for iter124 in self.annotations:
        iter124.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'traceId' in json_obj and json_obj['traceId'] is not None:
      self.traceId = long(json_obj['traceId'])
    if 'id' in json_obj and json_obj['id'] is not None:
      self.id = long(json_obj['id'])
    if 'parentId' in json_obj and json_obj['parentId'] is not None:
      self.parentId = long(json_obj['parentId'])
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']
    if 'annotations' in json_obj and json_obj['annotations'] is not None:
      self.annotations = []
      for _tmp_e125 in json_obj['annotations']:
        _struct126 = Annotation()
        _struct126.readFromJson(_tmp_e125, is_text=False)
        self.annotations.append(_struct126)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Trace:
  """
  Attributes:
   - id
   - spans
  """

  thrift_spec = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (iprot.__class__ == THeaderProtocol.THeaderProtocol and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.spans = []
          (_etype130, _size127) = iprot.readListBegin()
          if _size127 >= 0:
            for _i131 in six.moves.range(_size127):
              _elem132 = Span()
              _elem132.read(iprot)
              self.spans.append(_elem132)
          else: 
            while iprot.peekList():
              _elem133 = Span()
              _elem133.read(iprot)
              self.spans.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated or (oprot.__class__ == THeaderProtocol.THeaderProtocol and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS))
      return
    oprot.writeStructBegin('Trace')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.spans != None:
      oprot.writeFieldBegin('spans', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.spans))
      for iter134 in self.spans:
        iter134.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'id' in json_obj and json_obj['id'] is not None:
      self.id = long(json_obj['id'])
    if 'spans' in json_obj and json_obj['spans'] is not None:
      self.spans = []
      for _tmp_e135 in json_obj['spans']:
        _struct136 = Span()
        _struct136.readFromJson(_tmp_e135, is_text=False)
        self.spans.append(_struct136)

  def __repr__(self):
    L = []
    for key, value in six.iteritems(self.__dict__):
      padding = ' ' * (len(key) + 1)
      value = pprint.pformat(value)
      value = padding.join(value.splitlines(True))
      L.append('    %s=%s' % (key, value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

all_structs.append(BoltError)
BoltError.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'reason', True, None, 2, ), # 1
  (2, TType.STRING, 'context', True, None, 2, ), # 2
  (3, TType.I64, 'time', None, None, 2, ), # 3
)

def BoltError__init__(self, reason=None, context=None, time=None,):
  self.reason = reason
  self.context = context
  self.time = time

BoltError.__init__ = BoltError__init__

all_structs.append(Endpoint)
Endpoint.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ip', True, None, 2, ), # 1
  (2, TType.I16, 'port', None, None, 2, ), # 2
)

def Endpoint__init__(self, ip=None, port=None,):
  self.ip = ip
  self.port = port

Endpoint.__init__ = Endpoint__init__

all_structs.append(StreamMetadata)
StreamMetadata.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I32, 'grouping', None,   1, 2, ), # 2
)

def StreamMetadata__init__(self, name=None, grouping=StreamMetadata.thrift_spec[2][4],):
  self.name = name
  self.grouping = grouping

StreamMetadata.__init__ = StreamMetadata__init__

all_structs.append(ComputationMetadata)
ComputationMetadata.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.STRING, 'taskId', True, None, 2, ), # 2
  (3, TType.LIST, 'istreams', (TType.STRUCT,[StreamMetadata, StreamMetadata.thrift_spec, False]), None, 2, ), # 3
  (4, TType.LIST, 'ostreams', (TType.STRUCT,[StreamMetadata, StreamMetadata.thrift_spec, False]), None, 2, ), # 4
  (5, TType.STRUCT, 'proxyEndpoint', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 5
)

def ComputationMetadata__init__(self, name=None, taskId=None, istreams=None, ostreams=None, proxyEndpoint=None,):
  self.name = name
  self.taskId = taskId
  self.istreams = istreams
  self.ostreams = ostreams
  self.proxyEndpoint = proxyEndpoint

ComputationMetadata.__init__ = ComputationMetadata__init__

all_structs.append(ExecutorTaskInfoHelper)
ExecutorTaskInfoHelper.thrift_spec = (
  None, # 0
  (1, TType.I32, 'frameworkLoggingLevel', None, 1, 2, ), # 1
  (2, TType.STRING, 'user', True, None, 2, ), # 2
  (3, TType.STRING, 'frameworkVModule', True, None, 2, ), # 3
  (4, TType.STRUCT, 'scheduler', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'proxy', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'client', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'traceAggregator', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 7
  (8, TType.STRING, 'execName', True, None, 2, ), # 8
  (9, TType.STRING, 'folder', True, None, 2, ), # 9
  (10, TType.STRING, 'computationAliasName', True, None, 2, ), # 10
  (11, TType.LIST, 'clientArguments', (TType.STRING,True), None, 2, ), # 11
  (12, TType.LIST, 'environmentExtra', (TType.STRING,True), None, 2, ), # 12
  (13, TType.STRING, 'dockerContainer', True, None, 2, ), # 13
)

def ExecutorTaskInfoHelper__init__(self, frameworkLoggingLevel=ExecutorTaskInfoHelper.thrift_spec[1][4], user=None, frameworkVModule=None, scheduler=None, proxy=None, client=None, traceAggregator=None, execName=None, folder=None, computationAliasName=None, clientArguments=None, environmentExtra=None, dockerContainer=None,):
  self.frameworkLoggingLevel = frameworkLoggingLevel
  self.user = user
  self.frameworkVModule = frameworkVModule
  self.scheduler = scheduler
  self.proxy = proxy
  self.client = client
  self.traceAggregator = traceAggregator
  self.execName = execName
  self.folder = folder
  self.computationAliasName = computationAliasName
  self.clientArguments = clientArguments
  self.environmentExtra = environmentExtra
  self.dockerContainer = dockerContainer

ExecutorTaskInfoHelper.__init__ = ExecutorTaskInfoHelper__init__

all_structs.append(PhysicalComputationMetdata)
PhysicalComputationMetdata.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'taskId', True, None, 2, ), # 1
  (2, TType.STRING, 'slaveId', True, None, 2, ), # 2
  (3, TType.DOUBLE, 'cpus', None, None, 2, ), # 3
  (4, TType.I32, 'mem', None, None, 2, ), # 4
  (5, TType.I32, 'disk', None, None, 2, ), # 5
  (6, TType.STRUCT, 'taskHelper', [ExecutorTaskInfoHelper, ExecutorTaskInfoHelper.thrift_spec, False], None, 2, ), # 6
  (7, TType.BOOL, 'needsReconciliation', None, None, 2, ), # 7
)

def PhysicalComputationMetdata__init__(self, taskId=None, slaveId=None, cpus=None, mem=None, disk=None, taskHelper=None, needsReconciliation=None,):
  self.taskId = taskId
  self.slaveId = slaveId
  self.cpus = cpus
  self.mem = mem
  self.disk = disk
  self.taskHelper = taskHelper
  self.needsReconciliation = needsReconciliation

PhysicalComputationMetdata.__init__ = PhysicalComputationMetdata__init__

all_structs.append(PhysicalComputationLayout)
PhysicalComputationLayout.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.LIST, 'istreams', (TType.STRUCT,[StreamMetadata, StreamMetadata.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'ostreams', (TType.STRUCT,[StreamMetadata, StreamMetadata.thrift_spec, False]), None, 2, ), # 3
  (4, TType.LIST, 'nodes', (TType.STRUCT,[PhysicalComputationMetdata, PhysicalComputationMetdata.thrift_spec, False]), None, 2, ), # 4
)

def PhysicalComputationLayout__init__(self, name=None, istreams=None, ostreams=None, nodes=None,):
  self.name = name
  self.istreams = istreams
  self.ostreams = ostreams
  self.nodes = nodes

PhysicalComputationLayout.__init__ = PhysicalComputationLayout__init__

all_structs.append(SchedulerMetadata)
SchedulerMetadata.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'endpoint', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'version', None, None, 2, ), # 2
)

def SchedulerMetadata__init__(self, endpoint=None, version=None,):
  self.endpoint = endpoint
  self.version = version

SchedulerMetadata.__init__ = SchedulerMetadata__init__

all_structs.append(TopologyMetadata)
TopologyMetadata.thrift_spec = (
  None, # 0
  (1, TType.I32, 'version', None, 0, 2, ), # 1
  (2, TType.STRING, 'hash', True, None, 2, ), # 2
  (3, TType.MAP, 'computations', (TType.STRING,True,TType.STRUCT,[PhysicalComputationLayout, PhysicalComputationLayout.thrift_spec, False]), None, 2, ), # 3
)

def TopologyMetadata__init__(self, version=TopologyMetadata.thrift_spec[1][4], hash=None, computations=None,):
  self.version = version
  self.hash = hash
  self.computations = computations

TopologyMetadata.__init__ = TopologyMetadata__init__

all_structs.append(RecordMetadata)
RecordMetadata.thrift_spec = (
  None, # 0
  (1, TType.I64, 'traceId', None, 0, 2, ), # 1
  (2, TType.I64, 'sourceSpanId', None, 0, 2, ), # 2
  (3, TType.I32, 'flags', None, 0, 2, ), # 3
  (4, TType.I64, 'stream', None, 0, 2, ), # 4
  (5, TType.I64, 'timestamp', None, 0, 2, ), # 5
)

def RecordMetadata__init__(self, traceId=RecordMetadata.thrift_spec[1][4], sourceSpanId=RecordMetadata.thrift_spec[2][4], flags=RecordMetadata.thrift_spec[3][4], stream=RecordMetadata.thrift_spec[4][4], timestamp=RecordMetadata.thrift_spec[5][4],):
  self.traceId = traceId
  self.sourceSpanId = sourceSpanId
  self.flags = flags
  self.stream = stream
  self.timestamp = timestamp

RecordMetadata.__init__ = RecordMetadata__init__

all_structs.append(Record)
Record.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'meta', [RecordMetadata, RecordMetadata.thrift_spec, False], None, 2, ), # 1
  (2, TType.I64, 'time', None, 0, 2, ), # 2
  (3, TType.STRING, 'key', False, None, 2, ), # 3
  (4, TType.STRING, 'data', False, None, 2, ), # 4
  (5, TType.STRING, 'userStream', False, None, 2, ), # 5
)

def Record__init__(self, meta=None, time=Record.thrift_spec[2][4], key=None, data=None, userStream=None,):
  self.meta = meta
  self.time = time
  self.key = key
  self.data = data
  self.userStream = userStream

Record.__init__ = Record__init__

all_structs.append(ComputationTx)
ComputationTx.thrift_spec = (
  None, # 0
  (1, TType.I64, 'id', None, 0, 2, ), # 1
  (2, TType.LIST, 'records', (TType.STRUCT,[Record, Record.thrift_spec, False]), None, 2, ), # 2
  (3, TType.MAP, 'timers', (TType.STRING,True,TType.I64,None), None, 2, ), # 3
)

def ComputationTx__init__(self, id=ComputationTx.thrift_spec[1][4], records=None, timers=None,):
  self.id = id
  self.records = records
  self.timers = timers

ComputationTx.__init__ = ComputationTx__init__

all_structs.append(RichStream)
RichStream.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'stream', [StreamMetadata, StreamMetadata.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'computationName', True, None, 2, ), # 2
  (3, TType.LIST, 'endpoints', (TType.STRUCT,[Endpoint, Endpoint.thrift_spec, False]), None, 2, ), # 3
)

def RichStream__init__(self, stream=None, computationName=None, endpoints=None,):
  self.stream = stream
  self.computationName = computationName
  self.endpoints = endpoints

RichStream.__init__ = RichStream__init__

all_structs.append(BoltComputationRequest)
BoltComputationRequest.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', True, None, 2, ), # 1
  (2, TType.I64, 'instances', None, 1, 2, ), # 2
  (3, TType.DOUBLE, 'cpus', None, 0.1, 2, ), # 3
  (4, TType.I64, 'mem', None, 2048, 2, ), # 4
  (5, TType.I64, 'disk', None, 10240, 2, ), # 5
  (6, TType.STRUCT, 'taskHelper', [ExecutorTaskInfoHelper, ExecutorTaskInfoHelper.thrift_spec, False], None, 2, ), # 6
  (7, TType.BOOL, 'forceUpdateBinary', None, None, 2, ), # 7
  (8, TType.STRING, 'slug', False, None, 2, ), # 8
)

def BoltComputationRequest__init__(self, name=None, instances=BoltComputationRequest.thrift_spec[2][4], cpus=BoltComputationRequest.thrift_spec[3][4], mem=BoltComputationRequest.thrift_spec[4][4], disk=BoltComputationRequest.thrift_spec[5][4], taskHelper=None, forceUpdateBinary=None, slug=None,):
  self.name = name
  self.instances = instances
  self.cpus = cpus
  self.mem = mem
  self.disk = disk
  self.taskHelper = taskHelper
  self.forceUpdateBinary = forceUpdateBinary
  self.slug = slug

BoltComputationRequest.__init__ = BoltComputationRequest__init__

all_structs.append(Annotation)
Annotation.thrift_spec = (
  None, # 0
  (1, TType.I64, 'timestamp', None, None, 2, ), # 1
  (2, TType.I32, 'type', None, None, 2, ), # 2
  (3, TType.STRING, 'key', True, None, 2, ), # 3
  (4, TType.STRING, 'value', False, None, 2, ), # 4
  (5, TType.STRUCT, 'host', [Endpoint, Endpoint.thrift_spec, False], None, 2, ), # 5
)

def Annotation__init__(self, timestamp=None, type=None, key=None, value=None, host=None,):
  self.timestamp = timestamp
  self.type = type
  self.key = key
  self.value = value
  self.host = host

Annotation.__init__ = Annotation__init__

all_structs.append(Span)
Span.thrift_spec = (
  None, # 0
  (1, TType.I64, 'traceId', None, None, 2, ), # 1
  (2, TType.I64, 'id', None, None, 2, ), # 2
  (3, TType.I64, 'parentId', None, None, 2, ), # 3
  (4, TType.STRING, 'name', True, None, 2, ), # 4
  (5, TType.LIST, 'annotations', (TType.STRUCT,[Annotation, Annotation.thrift_spec, False]), None, 2, ), # 5
)

def Span__init__(self, traceId=None, id=None, parentId=None, name=None, annotations=None,):
  self.traceId = traceId
  self.id = id
  self.parentId = parentId
  self.name = name
  self.annotations = annotations

Span.__init__ = Span__init__

all_structs.append(Trace)
Trace.thrift_spec = (
  None, # 0
  (1, TType.I64, 'id', None, None, 2, ), # 1
  (2, TType.LIST, 'spans', (TType.STRUCT,[Span, Span.thrift_spec, False]), None, 2, ), # 2
)

def Trace__init__(self, id=None, spans=None,):
  self.id = id
  self.spans = spans

Trace.__init__ = Trace__init__

fix_spec(all_structs)
del all_structs
